# dp 之分组背包

## 说道dp，我记得刚上课时，就有个大佬说过，学好dp拿个牌子是没得问题的。那时候对dp就有了一个比较深刻的印象。

### 学到现在（其实也没学多少），碰到的题型，不多，也就像什么，背包（01 部分 完全 分组），最大上升子序列，区间dp，数位dp，其他的，我还没怎么碰到过，额，或者说，能用模版解决的就这些（就我所碰到的）；

今天我的博客记录的就是 一个分组背包 
[窜松门,hdu 3033](http://acm.hdu.edu.cn/showproblem.php?pid=3033)

### 看题

## I love sneakers!

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 5701    Accepted Submission(s): 2336


## Problem Description
After months of hard working, Iserlohn finally wins awesome amount of scholarship. As a great zealot of sneakers, he decides to spend all his money on them in a sneaker store.


There are several brands of sneakers that Iserlohn wants to collect, such as Air Jordan and Nike Pro. And each brand has released various products. For the reason that Iserlohn is definitely a sneaker-mania, he desires to buy at least one product for each brand.
Although the fixed price of each product has been labeled, Iserlohn sets values for each of them based on his own tendency. With handsome but limited money, he wants to maximize the total value of the shoes he is going to buy. Obviously, as a collector, he won’t buy the same product twice.
Now, Iserlohn needs you to help him find the best solution of his problem, which means to maximize the total value of the products he can buy.
 

## Input
Input contains multiple test cases. Each test case begins with three integers 1<=N<=100 representing the total number of products, 1 <= M<= 10000 the money Iserlohn gets, and 1<=K<=10 representing the sneaker brands. The following N lines each represents a product with three positive integers 1<=a<=k, b and c, 0<=b,c<100000, meaning the brand’s number it belongs, the labeled price, and the value of this product. Process to End Of File.
 

## Output
For each test case, print an integer which is the maximum total value of the sneakers that Iserlohn purchases. Print "Impossible" if Iserlohn's demands can’t be satisfied.
 

## Sample Input
5 10000 3
1 4 6
2 5 7
3 4 99
1 55 77
2 44 66
 

## Sample Output
255

### 不得不说，每次写acm题，都要阅读一篇长的阅读理解，这对于英语不好的我来说，很伤。
### 这里的关键就在于 怎么设这个dp；
我看的分组dp的模版，是这样用的，dp[i][j];，i代表组数，j代表背包的容量。
就拿这题举例子，dp[i][j]，来的地方只有三个;
对现在的这个鞋子，我可以不要；dp[i][j];
或者说这个鞋子我要了，那么存在两种情况，
这个鞋子是这个组的，并且不是第一次取；dp[i][j-money[k]]+happy[k];
或者说，我认为这是第一次在这个组里取；dp[i-1][j-money[k]]+happy[k];

好，现在可以说解绝了他的递推式，但是我怎么判断imposible 的情况，我想知道的是dp[总组数][总钱]的大小，我就需要知道，根据给的钱数，能不能推到我想要的值。那我在初始化dp的时候就要注意这个问题。
看代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<cmath>
#include<set>
#include<map>
#include<cstdlib>
#include<functional>
#include<climits>
#include<cctype>
#include<iomanip>
using namespace std;
typedef long long ll;  //hdu 3033
#define INF 0x3f3f3f3f
#define mod 1e9+7
#define clr(a,x) memset(a,x,sizeof(a))
const double eps = 1e-6;
int dp[12][10005];
int main()
{
    int n,m,t;
    int zu[105],mon[105],happy[105];
    while(scanf("%d%d%d",&n,&m,&t)==3)
    { 
        for(int i=0;i<n;i++)
        {
            scanf("%d%d%d",&zu[i],&mon[i],&happy[i]);
        }
        for(int i=0;i<=t;i++)
        {
            for(int j=0;j<=m;j++)
            {
                if(i==0)
                dp[i][j]=0;
                else
                dp[i][j]=-INF;
            }
        }
        for(int i=1;i<=t;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(zu[j]==i)
               {
                   for(int k=m;k>=mon[j];k--)
                   {
                       dp[i][k]=max(dp[i][k],max(dp[i][k-mon[j]]+happy[j],dp[i-1][k-mon[j]]+happy[j]));
                   }
               }
            }
        }
        if(dp[t][m]<0)
        printf("Impossible\n");
        else
        printf("%d\n",dp[t][m]);
    }
    return 0;
}
```

仅仅用来记录自己的一个知识点；
### 分组背包
        --langman