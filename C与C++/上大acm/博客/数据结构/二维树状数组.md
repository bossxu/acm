# Matrix 
## 二维树状数组入门题

[poj 2155](https://vjudge.net/problem/POJ-2155)
***
### 题目描述：
Given an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 <= i, j <= N). 

We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using "not" operation (if it is a '0' then change it into '1' otherwise change it into '0'). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. 

1. C x1 y1 x2 y2 (1 <= x1 <= x2 <= n, 1 <= y1 <= y2 <= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2). 
2. Q x y (1 <= x, y <= n) querys A[x, y]. 
Input
The first line of the input is an integer X (X <= 10) representing the number of test cases. The following X blocks each represents a test case. 

The first line of each block contains two numbers N and T (2 <= N <= 1000, 1 <= T <= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format "Q x y" or "C x1 y1 x2 y2", which has been described above. 
Output
For each querying output one line, which has an integer representing A[x, y]. 

There is a blank line between every two continuous test cases. 
Sample Input
1
2 10
C 2 1 2 2
Q 2 2
C 2 1 2 1
Q 1 1
C 1 1 2 1
C 1 2 1 2
C 1 1 2 2
Q 1 1
C 1 1 2 1
Q 2 1
Sample Output
1
0
0
1

>题目的意思就是说，让你更新一个区域内的值，每次更新，矩阵里面的值就取反一下，就是1变0，0变1；然后问你一个点，问他的状态。

>一开始，我想的是，我只学了一维的树状数组，我就把它转化成一个n*n的一维线段树，然后焦一发，然后t了；

>上网看题解，发现，这题要用到二维的树状数组来写，然后就写偏博客记录下这个二维树状数组是干啥的；怎么操作的，输进去什么得到什么；

就比如    我现在给你（2，2）（3，3）让你更新
我找的这个模版是这样解的
 我先确定一个右下标，我通过四次操作来解决这个问题，讲不清楚，看例子吧
 
 0 0 0 0         0 0 0 0        0 0 0 0     0 0 0 0    
 0 0 0 0  - - >  0 1 1 1  - ->  0 1 1 1 - ->0 1 1 0  --> 
 0 0 0 0   2,2   0 1 1 1  2,4   0 1 1 1 4,2 0 1 1 0 4,4 
 0 0 0 0         0 1 1 1        0 0 0 0     0 0 0 1

 0 0 0 0
 0 1 1 0
 0 1 1 0
 0 0 0 0

 然后就是这题的代码：
 ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<cmath>
#include<set>
#include<cstdlib>
#include<functional>
#include<climits>
#include<cctype>
#include<iomanip>
using namespace std;
typedef long long ll;
#define INF 0x3f3f3f3f
#define mod 1e9+7
#define clr(a,x) memset(a,x,sizeof(a))
const double eps = 1e-6;
// 知识点分解：二维树状数组
const int MAXN = 1005;
int treeNum[MAXN][MAXN];

int lowbit(int x){
    return x&(-x);
}

long long getSum(int x , int y){
    long long sum = 0;
    for(int i = x ; i > 0 ; i -= lowbit(i))
        for(int j = y ; j > 0 ; j -= lowbit(j))
            sum += treeNum[i][j];
    return sum;
}

void add(int x , int y , int val){
    for(int i = x ; i < MAXN ; i += lowbit(i))
        for(int j = y ; j < MAXN ; j += lowbit(j))
            treeNum[i][j] += val;
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n,q;
        clr(treeNum,0);
        scanf("%d%d",&n,&q);
        while(q--)
        {
            char c;
            getchar();
            scanf("%c",&c);
            if(c=='C')
            {
                int a,b,c,d;
                scanf("%d%d%d%d",&a,&b,&c,&d);
                add(a,b,1);
                add(a,d+1,-1);
                add(c+1,b,-1);
                add(c+1,d+1,1);
            }
            else
            {
              int a,b;
               scanf("%d%d",&a,&b);
              ll k =getSum(a,b);
              if(k%2==0 ) printf("0\n");
              else printf("1\n");
            }
        }
        cout<<endl;
    }
    return 0;
}
```
                   ---langman