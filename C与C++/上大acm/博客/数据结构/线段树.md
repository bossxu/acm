# 线段树

#### 主要模版的分布在于 求和，单点更新，区间更新；

> ## 先说个简单的模版，树状数组； 
#### 目前碰到的问题主要集中在解决 就是求和，然后在单点更新；
**先看个题**
[传送门 hdu 1166](https://vjudge.net/problem/HDU-1166)
***
题目的意思比较明显，就是很多的营地嘛，给你三个操作，一个是让你说出来，第几到第几营地一共有多少人，然后其他两个操作就是让你对其中某个营地进行修改，加人减人；题意很好懂，树状数组的裸题；
贴上代码，模版自己琢磨；
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<cmath>
#include<set>
#include<map>
#include<cstdlib>
#include<functional>
#include<climits>
#include<cctype>
#include<iomanip>
using namespace std;
typedef long long ll;
#define INF 0x3f3f3f3f
#define mod 1e9+7
#define clr(a,x) memset(a,x,sizeof(a))
const double eps = 1e-6;
int di[50005],t[50005];
int n;
//树状数组 
int lowbit(int x)
{
    return x&(-x);
}
void a_change(int x,int p)//将第x个数加p 
{
    while(x<=n)
    {
        t[x]+=p;
        x+=lowbit(x);
    }
    return;
}
void e_change(int x,int p)//将第x个数减p 
{
    while(x<=n)
    {
        t[x]-=p;
        x+=lowbit(x);
    }
    return;
}
int sum(int k)//前k个数的和 
{
    int ans=0;
    while(k>0)
    {
        ans+=t[k];
        k-=lowbit(k);
    }
    return ans;
}
int ask(int l,int r)//求l-r区间和 
{
    return sum(r)-sum(l-1); 
}
int main()
{
    int l;
    cin>>l;
    int c=0;
    while(l--)
    {      
           cin>>n;
           clr(t,0);
           char cao[7];
           for(int i=1;i<=n;i++)
           {
               cin>>di[i];
               a_change(i,di[i]);
           }
           printf("Case %d:\n",++c);
           while(scanf("%s",cao)!=EOF && cao[0]!='E')
           {
             int x,y;
             cin>>x>>y;
             if(cao[0]=='A')
             {
               a_change(x,y);
               continue;
             }
             if(cao[0]=='S')
             {
                 e_change(x,y);
                 continue;
             }
             if(cao[0]=='Q')
             {
                 int k= ask(x,y);
                 printf("%d\n",k);
                 continue;
             }
            }
       
    }
    return 0;
}
```
原理我也不是很懂，不过不要紧，慢慢来；

>## 线段树的问题

刚才的问题，我认为只能局限与一个值的加和减（其实好像改也行，把变化的值看成加减法）

不讨论这个了，线段树迟早要下手的；
老规矩，看题，读模版；
[hdu 1754](https://vjudge.net/problem/HDU-1754)
线段树模版主要就在于三个方面；
1：递归建树
2：向下更新
3：查询
#### 题意
题目和上面的差不多，只不过把加减换成了替换
贴代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<cmath>
#include<set>
#include<map>
#include<cstdlib>
#include<functional>
#include<climits>
#include<cctype>
#include<iomanip>
using namespace std;
typedef long long ll;
#define INF 0x3f3f3f3f
#define mod 1e9+7
#define clr(a,x) memset(a,x,sizeof(a))
const double eps = 1e-6;
//线段树 点的更新 区间最大
int n,m;
int score[200005];
struct Node{  
    int l,r,maxn;  
}tree[1000000];  
  
void Build(int t,int l,int r){  //建树 递归
    tree[t].l = l;  
    tree[t].r = r;  
    int mid = (l + r) / 2;  
    if(l == r){  
        tree[t].maxn = score[mid];  
        return;  
    }  
    Build(2*t,l,mid);  
    Build(2*t+1,mid+1,r);  
    tree[t].maxn = max(tree[2*t].maxn,tree[2*t+1].maxn);  
}  
  
int Query(int t,int x,int y){  //查询 t 根节点 x，y区间
    int l = tree[t].l;  
    int r = tree[t].r;  
    if(l == x && r == y)  
        return tree[t].maxn;  
    int mid = (l + r) / 2;  
    if(x <= mid && y <= mid)    return Query(2*t,x,y);
    else if(x > mid)    return Query(2*t+1,x,y);  
    else return max(Query(2*t,x,mid),Query(2*t+1,mid+1,y));  
}  
  
void Modify(int t,int x,int der){  t 根节点 x 下标 der 变成啥
    int l,r,mid;  
    l = tree[t].l;  
    r = tree[t].r;  
    mid = (l + r) / 2;  
    if(l == r){  
        tree[t].maxn = der;  
        return;  
    }  
    if(x <= mid)   Modify(2*t,x,der);  
    else    Modify(2*t+1,x,der);  
    tree[t].maxn = max(Query(2*t,l,mid),Query(2*t+1,mid+1,r));
}
int main()
{
    while(cin>>n>>m)
    {
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&score[i]);
        }
        char c;
        int x,y;
        Build(1,1,n);
        while(m--)
        {
            cin>>c>>x>>y;
            if(c=='Q')
            {
                if(x>y)//讲道理这里如果不换我也不知道会出啥事
                {
                    int t;
                    t=y;y=x;x=t;
                }
                int k= Query(1,x,y);
                printf("%d\n",k);
                continue;
            }
            if(c=='U')
            {
               Modify(1,x,y);
                continue;
            }
        }
    }
    return 0;
}
```
>我这里并没有对线段树进行解释和说明，可能很多人不明白，但在我看来，网上很多人都对这个有很好的解释，我只是一个喳喳，肯定讲不清楚的，你们不如去其他博客上看线段树的原理，我这里只能说是自己对模版该怎么用做了个小结。

***
**上面的是单点更新，然后便是重头戏，区间更新**
***
[hdu 1698](https://vjudge.net/problem/HDU-1698)
**很裸的题**
入门了解下什么是区间跟新
现在和上题就不太一样了，让你对某个区间的所有元素进行替换。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<cmath>
#include<set>
#include<map>
#include<cstdlib>
#include<functional>
#include<climits>
#include<cctype>
#include<iomanip>
using namespace std;
typedef long long ll;
#define INF 0x3f3f3f3f
#define mod 1e9+7
#define clr(a,x) memset(a,x,sizeof(a))
const double eps = 1e-6;
const int maxn = 100005;
// 知识点分解：区间更新
int tag[maxn*4];
void pushdown(int t,int m);
//  tag数组表示那个区间的数到底怎么更新
/*
  lazy 思想在于我在这个地方要不要向底层更新
  tag  意思在于记录是怎么变化
  很多模版都会有个lazy的数组
  但我抄的这个模版没有，不是很清楚为什么，但是黑盒嘛，知道进什么出什么就行
  这里的   tag 数组用来记录的是怎么变，加减？
          个人认为，比较重要的在于那个pushdown 的操作，你是怎么更新的，很重要。

*/
struct Treenode{
    int l,r;
    int sum=0;
}node[maxn*4];
void build(int t, int le, int ri)//建树
{
    node[t].l=le;
    node[t].r=ri;
    tag[t]=0;
    if(le==ri)
    {
      node[t].sum=1;
      return;
    }
    int mid=(le+ri)>>1;
    build(t*2,le,mid);
    build(t*2+1,mid+1,ri);
    node[t].sum=node[t*2].sum+node[t*2+1].sum;
}
void update(int t,int le,int ri,int c)//区间更新
{
   int L=node[t].l;
   int R=node[t].r;
   if(le==L && ri == R)
   {
      tag[t]=c;      //这里的操作就是这题的目的，替换如果是
                          // 加的话，就要变成+=；
      node[t].sum = (R-L+1)*c;
      return ;
   }
   if(L==R) return ;
   pushdown(t,R-L+1);
   int mid = (L+R)/2;
   if(ri<=mid) update(t<<1,le,ri,c);
   else if(le>mid) update(t<<1|1,le,ri,c);
   else//
   {
    update(t<<1,le,mid,c);
    update(t<<1|1,mid+1,ri,c);
   }
   node[t].sum=node[t*2].sum+node[t*2+1].sum;
}
void pushdown(int t,int m)//此处的目的在于更新节点，向底层更新
{
    if(tag[t])
    {
        tag[t<<1]=tag[t];
        tag[t<<1|1]=tag[t];
        node[t<<1].sum = tag[t]*(m-(m>>1));
        node[t<<1|1].sum = tag[t]*(m>>1);
        tag[t]=0;
    }
}
int query(int t,int l, int r)
{
    int L=node[t].l;
    int R=node[t].r;
    if(l==L && r==R)
    {
        return node[t].sum;
    }
    pushdown(t,R-L+1);
    int mid = (L+R)>>1;
    int ans=0;
    if(r<=mid)
    {
        ans+=query(t<<1,l,r);
    }
    else if(l>mid)
    {
        ans+=query(t<<1|1,l,r);
    }
    else
    {
        ans+=query(t<<1,l,mid);
        ans+=query(t<<1|1,mid+1,r);
    }
   return ans;
}
int main()
{
    int n,m,t;
    cin>>t;
    int co=0;
    while(t--)
    {
        cin>>n>>m;
        build(1,1,n);
        while(m--)
        {
          int a,b,c;
          cin>>a>>b>>c;
          if(a>b)
          {
              int t;
              t=a,a=b,b=t;
          }
          update(1,a,b,c);
        }
        printf("Case %d: The total value of the hook is %d.\n",++co,query(1,1,n));
    }
    return 0;
}
```

先记录这么多，模版必然是重要的，你不知道最简单的模版题，又怎么去处理非模版提。
