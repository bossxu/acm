<!DOCTYPE html>
<!-- saved from url=(0052)http://www.cnblogs.com/jbelial/articles/2116074.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<title>dd大牛的《背包九讲》 - 贺佐安 - 博客园</title>
<link type="text/css" rel="stylesheet" href="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/blog-common.css">
<link type="text/css" rel="stylesheet" href="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/86287.css">
<link id="mobile-style" media="only screen and (max-width: 768px)" type="text/css" rel="stylesheet" href="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/bundle-LessIsMore-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/jbelial/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/jbelial/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/jbelial/wlwmanifest.xml">
<script src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'jbelial', cb_enable_mathjax=false;var isLogined=false;</script>
<script src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/blog-common.js" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>
<!--PageBeginHtml Block Begin-->
<style type="text/css">
    .Abstract
    {
        padding: 15px;
        border: dotted 2px #999;
        color: #999;
        font-family: 'Microsoft Yahei';
        border-radius: 4px;
    }
        
    .First
    {
        margin: 10px 0;
        font-family: 'Microsoft Yahei';
        text-align: left;
        padding: 6px 20px;
        color: #fff;
        background: #55895B;
        font-size: 20px;
        border-radius: 4px;
        clear: both;
    }
        
        
    .Second
    {
        margin: 10px 0;
        font-family: 'Microsoft Yahei';
        padding: 6px 20px;
        background: #93C8A2;
        color: #fff;
        font-size: 18px;
        border-radius: 4px;
        clear: both;
    }
        
        
    .Third
    {
        margin: 10px 0;
        padding: 6px 20px;
        font-family: 'Microsoft Yahei';
        margin: 15px 0;
        font-size: 16px;
        color: fff;
        background: #C6EFD2;
        color: #999;
        border-radius: 4px;
        clear: both;
    }
    .note
    {
        margin: 10px 0;
        padding: 15px 20px 15px 60px;
        background: #FCFAA9 url('http://images.cnblogs.com/cnblogs_com/libaoheng/305804/o_yellow-pin.png') no-repeat 20px 0;
        font-size: 15px;
        font-family: 'Microsoft Yahei';
        box-shadow: 0 0 8px #aaa;
        clear: both;
    }
        
    .demo
    {
        text-align: left;
        padding: 6px 20px;
        overflow: auto;
        border-radius: 4px;
        background: orange;
        color: #fff;
        font-size: 16px;
        clear: both;
    }
        
    .cnblogs_Highlighter
    {
        border: solid 1px #ccc;
        clear: both;
    }
        
    .cnblogs_code
    {
        background: #EFFFF4;
        border: solid 0px #939393;
        font-size: 14px;
        clear: both;
        padding: 10px 20px;
    }
    .cnblogs_code pre
    {
        font-size: 14px;
    }
    .cnblogs_code span
    {
        font-family: Courier New;
        font-size: 14px;
    }
</style>
<!--PageBeginHtml Block End-->

<div id="home">
<div id="header">
	<div id="blogTitle">
		
<!--done-->
<div class="title"><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/jbelial/">桉树</a></div>
<div class="subtitle">There are no accidents.</div>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="http://www.cnblogs.com/">博客园</a></li>
<li id="nav_myhome"><a id="blog_nav_myhome" class="menu" href="http://www.cnblogs.com/jbelial/">首页</a></li>
<li id="nav_newpost"><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li id="nav_contact"><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/%E8%B4%BA%E4%BD%90%E5%AE%89">联系</a></li>
<li id="nav_rss">
<!----></li>
<li id="nav_admin"><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>

		<div class="blogStats">
			
			<div id="blog_stats">
<!--done-->
随笔-104&nbsp;
文章-11&nbsp;
评论-55&nbsp;
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/jbelial/articles/2116074.html">dd大牛的《背包九讲》</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body"><p>&nbsp;</p>
<p class="MsoNormal" style="margin: 0cm 0cm 0pt;"><span style="color: #888888;"><span style="font-family: Arial, sans-serif;" lang="EN-US">P01: 01</span><span style="font-family: 宋体;">背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">题目</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">N</span><span style="font-family: 宋体;">件物品和一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">的背包。第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品的费用是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]</span><span style="font-family: 宋体;">，价值是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]</span><span style="font-family: 宋体;">。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">基本思路</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">用子问题定义状态：即</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">表示前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品恰放入一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的背包可以获得的最大价值。则其状态转移方程便是：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">将前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品放入容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的背包中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">这个子问题，若只考虑第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品的策略（放或不放），那么就可以转化为一个只牵扯前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i-1</span><span style="font-family: 宋体;">件物品的问题。如果不放第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品，那么问题就转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i-1</span><span style="font-family: 宋体;">件物品放入容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的背包中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">；如果放第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品，那么问题就转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i-1</span><span style="font-family: 宋体;">件物品放入剩下的容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v-c[i]</span><span style="font-family: 宋体;">的背包中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">，此时能获得的最大价值就是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f [i-1][v-c[i]]</span><span style="font-family: 宋体;">再加上通过放入第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品获得的价值</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">注意</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">有意义当且仅当存在一个前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品的子集，其费用总和为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">。所以按照这个方程递推完毕后，最终的答案并不一定是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[N]
[V]</span><span style="font-family: 宋体;">，而是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[N][0..V]</span><span style="font-family: 宋体;">的最大值。如果将状态的定义中的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">恰</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">字去掉，在转移方程中就要再加入一项</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v-1]</span><span style="font-family: 宋体;">，这样就可以保证</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[N] [V]</span><span style="font-family: 宋体;">就是最后的答案。至于为什么这样就可以，由你自己来体会了。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">优化空间复杂度</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">以上方法的时间和空间复杂度均为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(N*V)</span><span style="font-family: 宋体;">，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V)</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">先考虑上面讲的基本思路如何实现，肯定是有一个主循环</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i=1..N</span><span style="font-family: 宋体;">，每次算出来二维数组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][0..V]</span><span style="font-family: 宋体;">的所有值。那么，如果只用一个数组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f [0..V]</span><span style="font-family: 宋体;">，能不能保证第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">次循环结束后</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v]</span><span style="font-family: 宋体;">中表示的就是我们定义的状态</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">呢？</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">是由</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1][v]</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1]
[v-c[i]]</span><span style="font-family: 宋体;">两个子问题递推而来，能否保证在推</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">时（也即在第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">次主循环中推</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v]</span><span style="font-family: 宋体;">时）能够得到</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1][v]</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1][v
-c[i]]</span><span style="font-family: 宋体;">的值呢？事实上，这要求在每次主循环中我们以</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v=V..0</span><span style="font-family: 宋体;">的顺序推</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v]</span><span style="font-family: 宋体;">，这样才能保证推</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v]</span><span style="font-family: 宋体;">时</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v-c[i]]</span><span style="font-family: 宋体;">保存的是状态</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i
-1][v-c[i]]</span><span style="font-family: 宋体;">的值。伪代码如下：</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
for i=1..N <br>
for v=V..0 <br>
f[v]=max{f[v],f[v-c[i]]+w[i]}; <br>
<br>
</span><span style="font-family: 宋体;">其中的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v]=max{f[v],f[v-c[i]]}</span><span style="font-family: 宋体;">一句恰就相当于我们的转移方程</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=max{f[i-1][v],f[i-
1][v-c[i]]}</span><span style="font-family: 宋体;">，因为现在的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v-c[i]]</span><span style="font-family: 宋体;">就相当于原来的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1][v-c[i]]</span><span style="font-family: 宋体;">。如果将</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的循环顺序从上面的逆序改成顺序的话，那么则成了</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">由</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v-c[i]]</span><span style="font-family: 宋体;">推知，与本题意不符，但它却是另一个重要的背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P02</span><span style="font-family: 宋体;">最简捷的解决方案，故学习只用一维数组解</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题是十分必要的。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">总结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
01</span><span style="font-family: 宋体;">背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
P02: </span><span style="font-family: 宋体;">完全背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">题目</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">N</span><span style="font-family: 宋体;">种物品和一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">的背包，每种物品都有无限件可用。第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品的费用是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]</span><span style="font-family: 宋体;">，价值是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]</span><span style="font-family: 宋体;">。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">基本思路</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这个问题非常类似于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0</span><span style="font-family: 宋体;">件、取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">件、取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2</span><span style="font-family: 宋体;">件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">……</span><span style="font-family: 宋体;">等很多种。如果仍然按照解</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包时的思路，令</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">表示前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品恰放入一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=
v}</span><span style="font-family: 宋体;">。这跟</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题一样有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(N*V)</span><span style="font-family: 宋体;">个状态需要求解，但求解每个状态的时间则不是常数了，求解状态</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">的时间是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(v/c[i])</span><span style="font-family: 宋体;">，总的复杂度是超过</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(VN)</span><span style="font-family: 宋体;">的。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">将</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">一个简单有效的优化</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">完全背包问题有一个很简单有效的优化，是这样的：若两件物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">、</span><span style="font-family: Arial, sans-serif;" lang="EN-US">j</span><span style="font-family: 宋体;">满足</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]&lt;=c[j]</span><span style="font-family: 宋体;">且</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]&gt;=w[j]</span><span style="font-family: 宋体;">，则将物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">j</span><span style="font-family: 宋体;">去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得</span><span style="font-family: Arial, sans-serif;" lang="EN-US">j</span><span style="font-family: 宋体;">换成物美价廉的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题求解</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">既然</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题来解。最简单的想法是，考虑到第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品最多选</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V/c [i]</span><span style="font-family: 宋体;">件，于是可以把第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V/c[i]</span><span style="font-family: 宋体;">件费用及价值均不变的物品，然后求解这个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题的思路：将一种物品拆成多件物品。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">更高效的转化方法是：把第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品拆成费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]*2^k</span><span style="font-family: 宋体;">、价值为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]*2^k</span><span style="font-family: 宋体;">的若干件物品，其中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">k</span><span style="font-family: 宋体;">满足</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]*2^k&lt;V</span><span style="font-family: 宋体;">。这是二进制的思想，因为不管最优策略选几件第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品，总可以表示成若干个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2^k</span><span style="font-family: 宋体;">件物品的和。这样把每种物品拆成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(log(V/c[i]))</span><span style="font-family: 宋体;">件物品，是一个很大的改进。</span><span style="font-family: 宋体;">但我们有更优的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(VN)</span><span style="font-family: 宋体;">的算法。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
* O(VN)</span><span style="font-family: 宋体;">的算法</span><span style="font-family: 宋体;">这个算法使用一维数组，先看伪代码：</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> &lt;pre class"example"&gt; for i=1..N for v=0..V
f[v]=max{f[v],f[v-c[i]]+w[i]}; <br>
<br>
<br>
<br>
</span><span style="font-family: 宋体;">你会发现，这个伪代码与</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P01</span><span style="font-family: 宋体;">的伪代码只有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P01</span><span style="font-family: 宋体;">中要按照</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v=V..0</span><span style="font-family: 宋体;">的逆序来循环。这是因为要保证第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">次循环中的状态</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">是由状态</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1][v-c[i]]</span><span style="font-family: 宋体;">递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">选入第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">这件策略时，依据的是一个绝无已经选入第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品的子结果</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i-1][v-c[i]]</span><span style="font-family: 宋体;">。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">加选一件第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">这种策略时，却正需要一个可能已选入第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品的子结果</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v-c[i]]</span><span style="font-family: 宋体;">，所以就可以并且必须采用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v= 0..V</span><span style="font-family: 宋体;">的顺序循环。这就是这个简单的程序为何成立的道理。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}</span><span style="font-family: 宋体;">，将这个方程用一维数组实现，便得到了上面的伪代码。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">总结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">基本思路</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">以及</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“O(VN)</span><span style="font-family: 宋体;">的算法</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
P03: </span><span style="font-family: 宋体;">多重背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">题目</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">N</span><span style="font-family: 宋体;">种物品和一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">的背包。第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品最多有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]</span><span style="font-family: 宋体;">件可用，每件费用是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]</span><span style="font-family: 宋体;">，价值是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]</span><span style="font-family: 宋体;">。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">基本算法</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]+1</span><span style="font-family: 宋体;">种策略：取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0</span><span style="font-family: 宋体;">件，取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">……</span><span style="font-family: 宋体;">取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
n[i]</span><span style="font-family: 宋体;">件。令</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">表示前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品恰放入一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的背包的最大权值，则：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=max{f[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]}</span><span style="font-family: 宋体;">。复杂度是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V*∑n[i])</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">另一种好想好写的基本方法是转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包求解：把第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品换成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]</span><span style="font-family: 宋体;">件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包中的物品，则得到了物品数为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">∑n[i]</span><span style="font-family: 宋体;">的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题，直接求解，复杂度仍然是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V*∑n[i])</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">但是我们期望将它转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品换成若干件物品，使得原问题中第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品可取的每种策略</span><span style="font-family: Arial, sans-serif;" lang="EN-US">——</span><span style="font-family: 宋体;">取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..n[i]</span><span style="font-family: 宋体;">件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">——</span><span style="font-family: 宋体;">均能等价于取若干件代换以后的物品。另外，取超过</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]</span><span style="font-family: 宋体;">件的策略必不能出现。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">方法是：将第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> 1,2,4,...,2^(k-1),n[i]-2^k+1</span><span style="font-family: 宋体;">，且</span><span style="font-family: Arial, sans-serif;" lang="EN-US">k</span><span style="font-family: 宋体;">是满足</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]-2^k+1&gt;0</span><span style="font-family: 宋体;">的最大整数。例如，如果</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]</span><span style="font-family: 宋体;">为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">13</span><span style="font-family: 宋体;">，就将这种物品分成系数分别为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1,2,4,6</span><span style="font-family: 宋体;">的四件物品。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">分成的这几件物品的系数和为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]</span><span style="font-family: 宋体;">，表明不可能取多于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n[i]</span><span style="font-family: 宋体;">件的第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品。另外这种方法也能保证对于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..n[i]</span><span style="font-family: 宋体;">间的每一个整数，均可以用若干个系数的和表示，这个证明可以分</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..2^k-1</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2^k..n[i]</span><span style="font-family: 宋体;">两段来分别讨论得出，并不难，希望你自己思考尝试一下。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">这样就将第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">种物品分成了</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(log n[i])</span><span style="font-family: 宋体;">种物品，将原问题转化为了复杂度为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V*∑log n[i])</span><span style="font-family: 宋体;">的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包问题，是很大的改进。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
O(VN)</span><span style="font-family: 宋体;">的算法</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">多重背包问题同样有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(VN)</span><span style="font-family: 宋体;">的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(1)</span><span style="font-family: 宋体;">的时间求解。由于用单调队列优化的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">DP</span><span style="font-family: 宋体;">已超出了</span><span style="font-family: Arial, sans-serif;" lang="EN-US">NOIP</span><span style="font-family: 宋体;">的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">男人八题</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">幻灯片上。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这里我们看到了将一个算法的复杂度由</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V*∑n[i])</span><span style="font-family: 宋体;">改进到</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V*∑log n[i])</span><span style="font-family: 宋体;">的过程，还知道了存在应用超出</span><span style="font-family: Arial, sans-serif;" lang="EN-US">NOIP</span><span style="font-family: 宋体;">范围的知识的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(VN)</span><span style="font-family: 宋体;">算法。希望你特别注意</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">拆分物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
<br>
<br>
P04: </span><span style="font-family: 宋体;">混合三种背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">如果将</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P01</span><span style="font-family: 宋体;">、</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P02</span><span style="font-family: 宋体;">、</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P03</span><span style="font-family: 宋体;">混合起来。也就是说，有的物品只可以取一次（</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
01</span><span style="font-family: 宋体;">背包与完全背包的混合</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">考虑到在</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P01</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P02</span><span style="font-family: 宋体;">中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(VN)</span><span style="font-family: 宋体;">。伪代码如下：</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
for i=1..N <br>
if </span><span style="font-family: 宋体;">第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
for v=V..0 <br>
f[v]=max{f[v],f[v-c[i]]+w[i]}; <br>
else if </span><span style="font-family: 宋体;">第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品是完全背包</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
for v=0..V <br>
f[v]=max{f[v],f[v-c[i]]+w[i]}; <br>
<br>
</span><span style="font-family: 宋体;">再加上多重背包</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">如果再加上有的物品最多可以取有限次，那么原则上也可以给出</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(VN)</span><span style="font-family: 宋体;">的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过</span><span style="font-family: Arial, sans-serif;" lang="EN-US">NOIP</span><span style="font-family: 宋体;">范围的算法的话，用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P03</span><span style="font-family: 宋体;">中将每个这类物品分成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(log n[i])</span><span style="font-family: 宋体;">个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包的物品的方法也已经很优了。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
P05: </span><span style="font-family: 宋体;">二维费用的背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">和代价</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2</span><span style="font-family: 宋体;">，第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品所需的两种代价分别为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">a[i]</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">b[i]</span><span style="font-family: 宋体;">。两种代价可付出的最大值（两种背包容量）分别为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">U</span><span style="font-family: 宋体;">。物品的价值为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">算法</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">费用加了一维，只需状态也加一维即可。设</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v][u]</span><span style="font-family: 宋体;">表示前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品付出两种代价分别为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">u</span><span style="font-family: 宋体;">时可获得的最大价值。状态转移方程就是：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f [i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}</span><span style="font-family: 宋体;">。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">u</span><span style="font-family: 宋体;">采用顺序的循环，当物品有如完全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">物品总个数的限制</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">有时，</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">二维费用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的条件是以这样一种隐含的方式给出的：最多只能取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">M</span><span style="font-family: 宋体;">件物品。这事实上相当于每件物品多了一种</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">件数</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的费用，每个物品的件数费用均为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">，可以付出的最大件数费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">M</span><span style="font-family: 宋体;">。换句话说，设</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[v][m]</span><span style="font-family: 宋体;">表示付出费用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">、最多选</span><span style="font-family: Arial, sans-serif;" lang="EN-US">m</span><span style="font-family: 宋体;">件时可得到的最大价值，则根据物品的类型（</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">、完全、多重）用不同的方法循环更新，最后在</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[0..V][0..M]</span><span style="font-family: 宋体;">范围内寻找答案。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">另外，如果要求</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">恰取</span><span style="font-family: Arial, sans-serif;" lang="EN-US">M</span><span style="font-family: 宋体;">件物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">，则在</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[0..V][M]</span><span style="font-family: 宋体;">范围内寻找答案。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
P06: </span><span style="font-family: 宋体;">分组的背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">N</span><span style="font-family: 宋体;">件物品和一个容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">的背包。第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">件物品的费用是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]</span><span style="font-family: 宋体;">，价值是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w[i]</span><span style="font-family: 宋体;">。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">算法</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[k][v]</span><span style="font-family: 宋体;">表示前</span><span style="font-family: Arial, sans-serif;" lang="EN-US">k</span><span style="font-family: 宋体;">组物品花费费用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">能取得的最大权值，则有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|</span><span style="font-family: 宋体;">物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">属于第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">k</span><span style="font-family: 宋体;">组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">}</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">使用一维数组的伪代码如下：</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
for </span><span style="font-family: 宋体;">所有的组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">k <br>
for </span><span style="font-family: 宋体;">所有的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">属于组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">k <br>
for v=V..0 <br>
f[v]=max{f[v],f[v-c[i]]+w[i]} <br>
<br>
</span><span style="font-family: 宋体;">另外，显然可以对每组中的物品应用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P02</span><span style="font-family: 宋体;">中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">一个简单有效的优化</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P07</span><span style="font-family: 宋体;">），由分组的背包问题进一步可定义</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的概念，十分有利于解题。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
P07: </span><span style="font-family: 宋体;">有依赖的背包问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">简化的问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这种背包问题的物品间存在某种</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">依赖</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的关系。也就是说，</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">依赖于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">j</span><span style="font-family: 宋体;">，表示若选物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">，则必须选物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">j</span><span style="font-family: 宋体;">。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">算法</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这个问题由</span><span style="font-family: Arial, sans-serif;" lang="EN-US">NOIP2006</span><span style="font-family: 宋体;">金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">主件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">，依赖于某主件的物品称为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">附件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">……</span><span style="font-family: 宋体;">无法用状态转移方程来表示如此多的策略。（事实上，设有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n</span><span style="font-family: 宋体;">个附件，则策略有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2^n+1</span><span style="font-family: 宋体;">个，为指数级。）</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P06</span><span style="font-family: 宋体;">中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">再考虑</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P06</span><span style="font-family: 宋体;">中的一句话：</span><span style="font-family: 宋体;">可以对每组中的物品应用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P02</span><span style="font-family: 宋体;">中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">一个简单有效的优化</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">附件集合</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">先进行一次</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包，得到费用依次为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..V-c[i]</span><span style="font-family: 宋体;">所有这些值时相应的最大价值</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f'[0..V-c[i]]</span><span style="font-family: 宋体;">。那么这个主件及它的附件集合相当于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V-c[i]+1</span><span style="font-family: 宋体;">个物品的物品组，其中费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c[i]+k</span><span style="font-family: 宋体;">的物品的价值为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f'[k]+w[i]</span><span style="font-family: 宋体;">。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包后，将主件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">转化为</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> V-c[i]+1</span><span style="font-family: 宋体;">个物品的物品组，就可以直接应用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P06</span><span style="font-family: 宋体;">的算法解决问题了。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">更一般的问题</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">更一般的问题是：依赖关系以图论中</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">森林</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01 </span><span style="font-family: 宋体;">背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">事实上，这是一种树形</span><span style="font-family: Arial, sans-serif;" lang="EN-US">DP</span><span style="font-family: 宋体;">，其特点是每个父节点都需要对它的各个儿子的属性进行一次</span><span style="font-family: Arial, sans-serif;" lang="EN-US">DP</span><span style="font-family: 宋体;">以求得自己的相关属性。这已经触及到了</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的思想。看完</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P08</span><span style="font-family: 宋体;">后，你会发现这个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">依赖关系树</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
NOIP2006</span><span style="font-family: 宋体;">的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">物品组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">依赖</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">我想说：失败不是什么丢人的事情，从失败中全无收获才是。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
P08: </span><span style="font-family: 宋体;">泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">定义</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">更严格的定义之。在背包容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">的背包问题中，泛化物品是一个定义域为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..V</span><span style="font-family: 宋体;">中的整数的函数</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">，当分配给它的费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">时，能得到的价值就是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h(v)</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h[0..V]</span><span style="font-family: 宋体;">，给它费用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">，可得到价值</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h[V]</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">一个费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c</span><span style="font-family: 宋体;">价值为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">w</span><span style="font-family: 宋体;">的物品，如果它是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包中的物品，那么把它看成泛化物品，它就是除了</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h(c)=w</span><span style="font-family: 宋体;">其它函数值都为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0</span><span style="font-family: 宋体;">的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">被</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c</span><span style="font-family: 宋体;">整除时有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h(v)=v/c*w</span><span style="font-family: 宋体;">，其它函数值均为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0</span><span style="font-family: 宋体;">。如果它是多重背包中重复次数最多为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">n</span><span style="font-family: 宋体;">的物品，那么它对应的泛化物品的函数有</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h(v)=v/c*w</span><span style="font-family: 宋体;">仅当</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">被</span><span style="font-family: Arial, sans-serif;" lang="EN-US">c</span><span style="font-family: 宋体;">整除且</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v/c&lt;=n</span><span style="font-family: 宋体;">，其它情况函数值均为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">一个物品组可以看作一个泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">。对于一个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..V</span><span style="font-family: 宋体;">中的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">，若物品组中不存在费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的的物品，则</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h(v)=0</span><span style="font-family: 宋体;">，否则</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h(v)</span><span style="font-family: 宋体;">为所有费用为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">的物品的最大价值。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">P07</span><span style="font-family: 宋体;">中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">泛化物品的和</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">如果面对两个泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">l</span><span style="font-family: 宋体;">，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..V</span><span style="font-family: 宋体;">的每一个整数</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">，可以求得费用</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">分配到</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">l</span><span style="font-family: 宋体;">中的最大价值</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f(v)</span><span style="font-family: 宋体;">。也即</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f(v)=max{h(k)
+l(v-k)|0&lt;=k&lt;=v}</span><span style="font-family: 宋体;">。可以看到，</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f</span><span style="font-family: 宋体;">也是一个由泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US">l</span><span style="font-family: 宋体;">决定的定义域为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..V</span><span style="font-family: 宋体;">的函数，也就是说，</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f</span><span style="font-family: 宋体;">是一个由泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">和</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> l</span><span style="font-family: 宋体;">决定的泛化物品。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">由此可以定义泛化物品的和：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">、</span><span style="font-family: Arial, sans-serif;" lang="EN-US">l</span><span style="font-family: 宋体;">都是泛化物品，若泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f</span><span style="font-family: 宋体;">满足</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f(v)=max{h(k)+l(v-k)|0&lt;=k&lt;=v}</span><span style="font-family: 宋体;">，则称</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f</span><span style="font-family: 宋体;">是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">h</span><span style="font-family: 宋体;">与</span><span style="font-family: Arial, sans-serif;" lang="EN-US">l</span><span style="font-family: 宋体;">的和，即</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f=h+l</span><span style="font-family: 宋体;">。这个运算的时间复杂度是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">O(V^2)</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">s</span><span style="font-family: 宋体;">，则答案就是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">s[0..V]</span><span style="font-family: 宋体;">中的最大值。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">背包问题的泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">求得：若背包容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v</span><span style="font-family: 宋体;">，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">——</span><span style="font-family: 宋体;">或者说问题所对应的一个定义域为非负整数的函数</span><span style="font-family: Arial, sans-serif;" lang="EN-US">——</span><span style="font-family: 宋体;">包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如</span><span style="font-family: Arial, sans-serif;" lang="EN-US">0..V</span><span style="font-family: 宋体;">）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> Scheme </span><span style="font-family: 宋体;">语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">模型的抽象程度</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">这一方面已经超出了</span><span style="font-family: Arial, sans-serif;" lang="EN-US">NOIP</span><span style="font-family: 宋体;">的要求，所以暂且看不懂也没关系。相信随着你的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">OI</span><span style="font-family: 宋体;">之路逐渐延伸，有一天你会理解的。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">我想说：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">思考</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">是一个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">OIer</span><span style="font-family: 宋体;">最重要的品质。简单的问题，深入思考以后，也能发现更多。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
P09: </span><span style="font-family: 宋体;">背包问题问法的变化</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f</span><span style="font-family: 宋体;">数组）之后得到。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">还有，如果要求的是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">总价值最小</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”“</span><span style="font-family: 宋体;">总件数最小</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">，只需简单的将上面的状态转移方程中的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">max</span><span style="font-family: 宋体;">改成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">min</span><span style="font-family: 宋体;">即可。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">下面说一些变化更大的问法。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">输出方案</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">还是以</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包为例，方程为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}</span><span style="font-family: 宋体;">。再用一个数组</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i]
[v]</span><span style="font-family: 宋体;">，设</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i][v]=0</span><span style="font-family: 宋体;">表示推出</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">的值时是采用了方程的前一项（也即</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=f[i-1][v]</span><span style="font-family: 宋体;">），</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i][v]</span><span style="font-family: 宋体;">表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">个物品及选了第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">个物品。那么输出方案的伪代码可以这样写（设最终状态为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[N][V]</span><span style="font-family: 宋体;">）：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
i=N <br>
v=V <br>
while(i&gt;0) <br>
if(g[i][v]==0) <br>
print "</span><span style="font-family: 宋体;">未选第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">项物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">" <br>
else if(g[i][v]==1) <br>
print "</span><span style="font-family: 宋体;">选了第</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">项物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">" <br>
v=v-c[i] <br>
<br>
</span><span style="font-family: 宋体;">另外，采用方程的前一项或后一项也可以在输出方案的过程中根据</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">的值实时地求出来，也即不须纪录</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g</span><span style="font-family: 宋体;">数组，将上述代码中的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i] [v]==0</span><span style="font-family: 宋体;">改成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]==f[i-1][v]</span><span style="font-family: 宋体;">，</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i][v]==1</span><span style="font-family: 宋体;">改成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]==f[i-1][v-c[i]]+w[i]</span><span style="font-family: 宋体;">也可。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">输出字典序最小的最优方案</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这里</span><span style="font-family: Arial, sans-serif;" lang="EN-US">“</span><span style="font-family: 宋体;">字典序最小</span><span style="font-family: Arial, sans-serif;" lang="EN-US">”</span><span style="font-family: 宋体;">的意思是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1..N</span><span style="font-family: 宋体;">号物品的选择方案排列出来以后字典序最小。以输出</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包最小字典序的方案为例。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">的最优方案，那么答案一定包含物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">，原问题转化为一个背包容量为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">v-c[1]</span><span style="font-family: 宋体;">，物品为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2..N</span><span style="font-family: 宋体;">的子问题。反之，如果答案不包含物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">，则转化成背包容量仍为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">V</span><span style="font-family: 宋体;">，物品为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">2..N</span><span style="font-family: 宋体;">的子问题。不管答案怎样，子问题的物品都是以</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i..N</span><span style="font-family: 宋体;">而非前所述的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1..i</span><span style="font-family: 宋体;">的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从</span><span style="font-family: Arial, sans-serif;" lang="EN-US">N</span><span style="font-family: 宋体;">到</span><span style="font-family: Arial, sans-serif;" lang="EN-US">1</span><span style="font-family: 宋体;">输入时，如果</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]==f[i-v]</span><span style="font-family: 宋体;">及</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]==f[i-1][f-c[i]]+w[i]</span><span style="font-family: 宋体;">同时成立，应该按照后者（即选择了物品</span><span style="font-family: Arial, sans-serif;" lang="EN-US">i</span><span style="font-family: 宋体;">）来输出方案。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">求方案总数</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">对于这类改变问法的问题，一般只需将状态转移方程中的</span><span style="font-family: Arial, sans-serif;" lang="EN-US">max</span><span style="font-family: 宋体;">改成</span><span style="font-family: Arial, sans-serif;" lang="EN-US">sum</span><span style="font-family: 宋体;">即可。例如若每件物品均是</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包中的物品，转移方程即为</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]=sum{f[i-1][v],f[i-1][v-c[i]]+w[i]}</span><span style="font-family: 宋体;">，初始条件</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[0][0]=1</span><span style="font-family: 宋体;">。</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
</span><span style="font-family: 宋体;">事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">最优方案的总数</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">这里的最优方案是指物品总价值最大的方案。还是以</span><span style="font-family: Arial, sans-serif;" lang="EN-US">01</span><span style="font-family: 宋体;">背包为例。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">意义同前述，</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i][v]</span><span style="font-family: 宋体;">表示这个子问题的最优方案的总数，则在求</span><span style="font-family: Arial, sans-serif;" lang="EN-US">f[i][v]</span><span style="font-family: 宋体;">的同时求</span><span style="font-family: Arial, sans-serif;" lang="EN-US">g[i][v]</span><span style="font-family: 宋体;">的伪代码如下：</span><span style="font-family: Arial, sans-serif;" lang="EN-US">
<br>
<br>
for i=1..N <br>
for v=0..V <br>
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} <br>
g[i][v]=0 <br>
if(f[i][v]==f[i-1][v]) <br>
inc(g[i][v],g[i-1][v] <br>
if(f[i][v]==f[i-1][v-c[i]]+w[i]) <br>
inc(g[i][v],g[i-1][v-c[i]]) <br>
<br>
</span><span style="font-family: 宋体;">如果你是第一次看到这样的问题，请仔细体会上面的伪代码。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">小结</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
</span><span style="font-family: 宋体;">显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于</span><span style="font-family: Arial, sans-serif;" lang="EN-US">NOIP</span><span style="font-family: 宋体;">，应该也不难想出算法。</span><span style="font-family: Arial, sans-serif;" lang="EN-US"> <br>
<br>
</span><span style="font-family: 宋体;">触类旁通、举一反三，应该也是一个</span><span style="font-family: Arial, sans-serif;" lang="EN-US">OIer</span><span style="font-family: 宋体;">应有的品质吧。</span></span></p>
<p>&nbsp;</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="http://www.cnblogs.com/jbelial/category/311892.html" target="_blank">背包问题</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(2116074,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;6e482382-f459-e011-a53f-842b2b196315&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/jbelial/" target="_blank"><img src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/u287127.jpg" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/jbelial/">贺佐安</a><br>
            <a href="http://home.cnblogs.com/u/jbelial/followees">关注 - 7</a><br>
            <a href="http://home.cnblogs.com/u/jbelial/followers">粉丝 - 209</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;6e482382-f459-e011-a53f-842b2b196315&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(2116074,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">8</span>
    </div>
    <div class="buryit" onclick="votePost(2116074,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
</div>
<div class="clear"></div>
<div id="post_next_prev"><a href="http://www.cnblogs.com/jbelial/archive/2011/07/25/2116049.html" class="p_n_p_prefix">« </a> 上一篇：<a href="http://www.cnblogs.com/jbelial/archive/2011/07/25/2116049.html" title="发布于2011-07-25 12:14">HDU 2191 悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</a><br><a href="http://www.cnblogs.com/jbelial/archive/2011/07/25/2116160.html" class="p_n_p_prefix">» </a> 下一篇：<a href="http://www.cnblogs.com/jbelial/archive/2011/07/25/2116160.html" title="发布于2011-07-25 14:34">HDU 3732 Ahui Writes Word</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2011-07-25 13:11</span> <a href="http://www.cnblogs.com/jbelial/">贺佐安</a> 阅读(<span id="post_view_count">36500</span>) 评论(<span id="post_comment_count">4</span>) &nbsp;<a href="https://i.cnblogs.com/EditArticles.aspx?postid=2116074" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/jbelial/articles/2116074.html#" onclick="AddToWz(2116074);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=86287,cb_entryId=2116074,cb_blogApp=currentBlogApp,cb_blogUserGuid='6e482382-f459-e011-a53f-842b2b196315',cb_entryCreatedDate='2011/7/25 13:11:00';loadViewCount(cb_entryId);</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<!--done-->
<div class="feedback_area_title">评论列表</div>
<div class="feedbackNoItems"></div>
	

		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jbelial/articles/2116074.html#3456208" class="layer">#1楼</a><a name="3456208" id="comment_anchor_3456208"></a>  <span class="comment_date">2016-06-21 15:47</span> <a id="a_comment_author_3456208" href="http://www.cnblogs.com/hnist/" target="_blank">change_yourself</a> <a href="http://msg.cnblogs.com/send/change_yourself" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3456208" class="blog_comment_body">看懂是一种快乐</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3456208,&#39;Digg&#39;,this)">支持(1)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3456208,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3456208_avatar" style="display:none;">http://pic.cnblogs.com/face/929041/20160405153409.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jbelial/articles/2116074.html#3660411" class="layer">#2楼</a><a name="3660411" id="comment_anchor_3660411"></a>  <span class="comment_date">2017-04-06 12:56</span> <a id="a_comment_author_3660411" href="http://home.cnblogs.com/u/1140960/" target="_blank">黄志强</a> <a href="http://msg.cnblogs.com/send/%E9%BB%84%E5%BF%97%E5%BC%BA" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3660411" class="blog_comment_body">大牛总结的很到位</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3660411,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3660411,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jbelial/articles/2116074.html#3716499" class="layer">#3楼</a><a name="3716499" id="comment_anchor_3716499"></a>  <span class="comment_date">2017-06-17 16:41</span> <a id="a_comment_author_3716499" href="http://www.cnblogs.com/thmyl/" target="_blank">Echo宝贝儿</a> <a href="http://msg.cnblogs.com/send/Echo%E5%AE%9D%E8%B4%9D%E5%84%BF" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3716499" class="blog_comment_body">分组背包的一维伪代码写错了吧</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3716499,&#39;Digg&#39;,this)">支持(1)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3716499,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3716499_avatar" style="display:none;">http://pic.cnblogs.com/face/1008672/20160814092655.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/jbelial/articles/2116074.html#3779671" class="layer">#4楼</a><a name="3779671" id="comment_anchor_3779671"></a><span id="comment-maxId" style="display:none;">3779671</span><span id="comment-maxDate" style="display:none;">2017/9/10 10:15:49</span>  <span class="comment_date">2017-09-10 10:15</span> <a id="a_comment_author_3779671" href="http://home.cnblogs.com/u/1236257/" target="_blank">wlqfzs</a> <a href="http://msg.cnblogs.com/send/wlqfzs" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3779671" class="blog_comment_body"><a href="http://www.cnblogs.com/jbelial/articles/2116074.html#3716499" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3716499);">@</a>
Echo宝贝儿<br><fieldset class="comment_quote"><legend><a href="http://www.cnblogs.com/jbelial/articles/2116074.html#3716499" title="查看引用原文">引用</a></legend><br>分组背包的一维伪代码写错了吧<br></fieldset><br>是错了</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3779671,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3779671,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	<div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="http://www.cnblogs.com/jbelial/articles/2116074.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/jbelial/articles/2116074.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank">【推荐】50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库</a><br><a href="https://cloud.tencent.com/act/free?fromSource=gwzcw.436817.436817.436817" target="_blank">【力荐】普惠云计算 0门槛体验 30+云产品免费半年</a><br><a href="http://www.gcpowertools.com.cn/products/spreadjs/?utm_source=cnblogs&amp;utm_medium=blogpage&amp;utm_term=bottom&amp;utm_content=SpreadJS&amp;utm_campaign=community" target="_blank">【推荐】可嵌入您系统的“在线Excel”！SpreadJS 纯前端表格控件</a><br><a href="http://click.aliyun.com/m/18488/" target="_blank">【推荐】阿里云“全民云计算”优惠升级</a><br></div>
<div id="opt_under_post"></div>
<div id="cnblogs_c1" class="c_ad_block"><a href="https://www.mtyun.com/promote/ab6dceaa-8a4f-45b4-9946-e2fe5564266a/" target="_blank"><img width="300" height="250" src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/24442-20170906183359226-1435856414.jpg" alt="美团云0907"></a></div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="http://news.cnblogs.com/n/578022/" target="_blank">Apache Struts项目对Equifax事件发表声明</a><br> ·  <a href="http://news.cnblogs.com/n/578021/" target="_blank">怕买不到iPhone X？苹果：春节前备货一个亿！</a><br> ·  <a href="http://news.cnblogs.com/n/578020/" target="_blank">日本公司推出感应机器人！欲缓解劳动力短缺</a><br> ·  <a href="http://news.cnblogs.com/n/578019/" target="_blank">小米发布全面屏第二代MIX2售价3299元起</a><br> ·  <a href="http://news.cnblogs.com/n/578018/" target="_blank">扎克伯格再上法庭，股权捐赠慈善业引股东纷争</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="cnblogs_c2" class="c_ad_block"><a href="https://www.jiguang.cn/devservice?source=bky&amp;hmsr=%E5%8D%9A%E5%AE%A2%E5%9B%AD&amp;hmpl=&amp;hmcu=&amp;hmkw=&amp;hmci=" target="_blank"><img width="468" height="60" src="./dd大牛的《背包九讲》 - 贺佐安 - 博客园_files/24442-20170908132742304-1045119416.gif" alt="极光0908"></a></div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="http://kb.cnblogs.com/page/575829/" target="_blank">做到这一点，你也可以成为优秀的程序员</a><br> ·  <a href="http://kb.cnblogs.com/page/566880/" target="_blank">写给立志做码农的大学生</a><br> ·  <a href="http://kb.cnblogs.com/page/569057/" target="_blank">架构腐化之谜</a><br> ·  <a href="http://kb.cnblogs.com/page/572854/" target="_blank">学会思考，而不只是编程</a><br> ·  <a href="http://kb.cnblogs.com/page/574767/" target="_blank">编写Shell脚本的最佳实践</a><br></div>» <a href="http://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><div id="profile_block">昵称：<a href="http://home.cnblogs.com/u/jbelial/">贺佐安</a><br>园龄：<a href="http://home.cnblogs.com/u/jbelial/" title="入园时间：2011-03-29">6年5个月</a><br>粉丝：<a href="http://home.cnblogs.com/u/jbelial/followers/">209</a><br>关注：<a href="http://home.cnblogs.com/u/jbelial/followees/">7</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;6e482382-f459-e011-a53f-842b2b196315&#39;)">+加关注</a></div></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2017/08/01&#39;);return false;">&lt;</a></td><td align="center">2017年9月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2017/10/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td class="CalOtherMonthDay" align="center">31</td><td align="center">1</td><td class="CalWeekendDay" align="center">2</td></tr><tr><td class="CalWeekendDay" align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td class="CalWeekendDay" align="center">9</td></tr><tr><td class="CalWeekendDay" align="center">10</td><td class="CalTodayDay" align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td class="CalWeekendDay" align="center">16</td></tr><tr><td class="CalWeekendDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalWeekendDay" align="center">23</td></tr><tr><td class="CalWeekendDay" align="center">24</td><td align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td align="center">29</td><td class="CalWeekendDay" align="center">30</td></tr><tr><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block">
<div id="sidebar_search" class="mySearch">
<h3 class="catListTitle">搜索</h3>
<div id="sidebar_search_box">
<div id="widget_my_zzk" class="div_my_zzk"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="input_my_zzk">&nbsp;<input onclick="zzk_go()" type="button" value="找找看" id="btnZzk" class="btn_my_zzk"></div>
<div id="widget_my_google" class="div_my_zzk"><input type="text" name="google_q" id="google_q" onkeydown="return google_go_enter(event)" class="input_my_zzk">&nbsp;<input onclick="google_go()" type="button" value="谷歌搜索" class="btn_my_zzk"></div>
</div>
</div>

</div><div id="sidebar_categories">
<div class="catListPostCategory">
<h3 class="catListTitle">随笔分类</h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="http://www.cnblogs.com/jbelial/category/314165.html">ACM(7)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="http://www.cnblogs.com/jbelial/category/359826.html">JavaEE(23)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="http://www.cnblogs.com/jbelial/category/326857.html">JAVA基础(29)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="http://www.cnblogs.com/jbelial/category/399661.html">JMF媒体框架</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="http://www.cnblogs.com/jbelial/category/323926.html">KMP(2)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="http://www.cnblogs.com/jbelial/category/312155.html">背包问题(8)</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="http://www.cnblogs.com/jbelial/category/338499.html">成长(6)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="http://www.cnblogs.com/jbelial/category/381345.html">错误集合(11)</a> </li>

<li><a id="CatList_LinkList_0_Link_8" href="http://www.cnblogs.com/jbelial/category/313900.html">动态规划(3)</a> </li>

<li><a id="CatList_LinkList_0_Link_9" href="http://www.cnblogs.com/jbelial/category/314052.html">计算几何(6)</a> </li>

<li><a id="CatList_LinkList_0_Link_10" href="http://www.cnblogs.com/jbelial/category/312154.html">母函数(7)</a> </li>

<li><a id="CatList_LinkList_0_Link_11" href="http://www.cnblogs.com/jbelial/category/323924.html">数据结构</a> </li>

</ul>

</div>

<div class="catListArticleCategory">
<h3 class="catListTitle">文章分类</h3>

<ul>

<li><a id="CatList_LinkList_1_Link_0" href="http://www.cnblogs.com/jbelial/category/311654.html">&lt;算法导论&gt;</a> </li>

<li><a id="CatList_LinkList_1_Link_1" href="http://www.cnblogs.com/jbelial/category/290707.html">ACM(2)</a> </li>

<li><a id="CatList_LinkList_1_Link_2" href="http://www.cnblogs.com/jbelial/category/314885.html">IT摘</a> </li>

<li><a id="CatList_LinkList_1_Link_3" href="http://www.cnblogs.com/jbelial/category/359825.html">JavaWeb</a> </li>

<li><a id="CatList_LinkList_1_Link_4" href="http://www.cnblogs.com/jbelial/category/311892.html">背包问题(4)</a> </li>

<li><a id="CatList_LinkList_1_Link_5" href="http://www.cnblogs.com/jbelial/category/312150.html">母函数(2)</a> </li>

<li><a id="CatList_LinkList_1_Link_6" href="http://www.cnblogs.com/jbelial/category/312780.html">字典树(1)</a> </li>

</ul>

</div>

</div><div id="sidebar_scorerank" class="sidebar-block">
<div class="catListBlogRank">
<h3 class="catListTitle">积分与排名</h3>
<ul>
	<li class="liScore">
		积分 -	128101
	</li>
	<li class="liRank">
		排名 -	1996
	</li>
</ul>
</div>


</div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2017 贺佐安
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


</body></html>